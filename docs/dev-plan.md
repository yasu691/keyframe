# 仕様書（プロトタイプ用）なのだ

## 1) 目的・スコープなのだ

* **目的**: 自分の「調子（リズム）」と「その時に見ていたもの」を定量記録し、集中度／成果モニタリングの土台を作るのだ
* **観測対象**:

  1. キー入力の量とリズム（KPM/KPS15/インターバル中央値/Backspace比）
  2. 画面スクリーンショット → Azure OpenAI で文字起こし（テキスト化）なのだ
* **プラットフォーム**: macOS / Windows（Python）なのだ

## 2) 記録粒度・ライフサイクルなのだ

* **interval\_sec**: 60秒固定
* **1レコード=60秒間のペア**: 「タイピング指標」＋「OCRテキスト」
* **スクショ**: 撮影→OCR送信→**成功/最終失敗で削除**（本体には残さない）なのだ
* **時刻**: `ts_utc`（UTC, ISO8601）なのだ

## 3) データモデル（JSONL, 日別ファイル）なのだ

```json
{
  "ts_utc": "2025-08-27T10:00:00Z",
  "interval_sec": 60,
  "typing": {
    "kpm": 132,
    "kps15": 2.3,
    "median_latency_ms": 95.0,
    "backspace_pct": 4.1,
    "idle": false,
    "total_keys_cum": 123456
  },
  "screen": {
    "screenshot_path": null,
    "ocr_text": "YouTube - LoFi beats to relax/study to ...",
    "active_app": "Google Chrome",
    "active_title": "YouTube - lo-fi radio"
  },
  "alerts": [
    {
      "rule_id": "distraction.youtube",
      "level": "warn",
      "reason": "ocr_text contains 'YouTube'"
    }
  ]
}
```

* `screenshot_path` は**最終的に必ず null**（削除済み）なのだ
* OCR最終失敗時は `ocr_text` は空文字 `""`、`alerts` は判定不可なら空配列なのだ

## 4) OCRとリトライキャッシュなのだ

* **送信対象**: スクショ**のみ**をAzure OpenAIに送る（キーログは送らない）なのだ
* **前処理**: 長辺1920pxへリサイズ、JPEG品質70で圧縮なのだ
* **リトライ**: `max_retries=3`、バックオフ **60s→120s→300s**、APIタイムアウト20sなのだ
* **キャッシュ保存先**: `~/.keystats/cache/DATE/…jpg` なのだ
* **削除条件**: 成功→即削除／最終失敗→即削除／孤児は**24h**で掃除なのだ
* **キュー上限**: **500枚 or 2GB** 超で古い順ドロップ（ドロップ分は `ocr_text=""` 確定）なのだ

## 5) アクティブウィンドウ情報なのだ

* `active_app`, `active_title` を添付（取得失敗時は空）
* Windows: pywin32＋psutil、macOS: NSWorkspace＋Quartz（権限前提）なのだ

## 6) アラート（注意散漫検知）なのだ

* **入力**: `ocr_text` / `active_app` / `active_title` なのだ
* **ブラックリスト語**（初期）: `youtube|tiktok|netflix|prime video|x.com|steam|twitch`（大小/全半角正規化・URL含む）なのだ
* **許可リスト**: 後回し（設計フックのみ）なのだ
* **判定**:

  * 即時 **WARN**: 1回マッチ
  * 直近**5レコード中3回**で **ERROR**（約5分）
  * **デバウンス**: 同一`rule_id`通知は**最短10分**間隔、ERRORはWARNを上書きなのだ

## 7) 通知（Tkinterポップアップ）なのだ

* 本体とは**別プロセス**の短命GUIを起動して表示するのだ
* 既定: **timeout=10秒**, **snooze=10分**, **debounce=10分** なのだ
* WARN=琥珀、ERROR=朱色、サイズ480×180、中央・最前面、OK/閉じる/Snoozeボタンなのだ
* ヘッドレス時や失敗時は**サウンド/ログ**にフォールバックするのだ

## 8) 保持・ローテーションなのだ

* JSONL: 日別、既定**90日**保持
* ログ: 2MB×5世代のローテーション
* 画像: **キャッシュのみ**（成功/諦め時に即削除、孤児24h掃除）なのだ

## 9) セキュリティ・権限なのだ

* 送信先は**Azure OpenAIのみ**（他所には送らない）
* macOS: アクセシビリティ＋画面収録の許可が必要
* Windows: 通常は不要だが企業ポリシーで制限の可能性ありなのだ

## 10) 非機能要件（目安）なのだ

* 常駐CPU < 2%、RSS < 150MB（スクショ時一時上振れ可）
* ディスク上限5GBで古いキャッシュから整理
* オフラインでも毎分レコードを継続生成（`ocr_text`空でOK）なのだ

## 11) 受け入れ基準（Acceptance）なのだ

1. オフライン状態でも**毎分1行**のJSONLが増えるのだ
2. 回線復帰後、キャッシュのOCRが成功し、**元画像は削除**されるのだ
3. 5分間でYouTubeが**3回**検出されたら**ERROR**が**1回だけ**表示（デバウンス有効）なのだ
4. 24時間経ったキャッシュ画像は自動削除されるのだ
5. すべてのレコードで `screenshot_path=null` が維持され、`ts_utc` はUTCで単調増加なのだ

---

# 段階的実装手順（安全運転）なのだ

## フェーズ0：骨組み

1. **設定ローダ**（env/ini）：Azureエンドポイント・APIキー・保存パスを読む
2. **タイムスライサ**：60秒ごとにコールバックを叩くスケジューラ作成（単体テスト）なのだ

## フェーズ1：タイピング計測（OCR無し）

3. キーフック基盤（pynput）実装、**KPM/KPS15/median/backspace/idle** をローリング計算
4. JSONLライタ（追記）実装、**毎分1行**を書き出す

   * ✅ テスト: 2分動かして**2行**出る／値が0で落ちないことなのだ

## フェーズ2：スクショとメタ

5. スクショ取得（mss+Pillow）、1920px/品質70保存
6. アクティブウィンドウ取得（Win/mac）を添付（失敗時は空で落ちない）

   * ✅ テスト: 日別ディレクトリに**1分1枚**できることなのだ

## フェーズ3：Azure OCRラッパ

7. 画像→Azure OpenAI呼び出しの**薄いクライアント**作成（タイムアウト20s）
8. 成功でテキスト返却、失敗で例外に正規化

   * ✅ テスト: 疑似画像で**成功/失敗/429**の分岐が通ることなのだ

## フェーズ4：リトライキャッシュ

9. キャッシュディレクトリ・キュー管理（上限**500枚 or 2GB**）
10. バックオフ **60/120/300s**、`max_retries=3`、成功/最終失敗で**削除**

    * ✅ テスト: オフライン→復帰で**キャッシュが空**になるまで再処理されることなのだ

## フェーズ5：アラートエンジン

11. ブラックリスト正規化・判定（大小/全半角/URL）
12. 直近**5レコード中3回**でERRORへ昇格、デバウンス10分

    * ✅ テスト: 人工OCRで**WARN→ERROR**遷移を確認なのだ

## フェーズ6：Tk通知（別プロセス）

13. `alert_popup.py` をCLI化（timeout=10s, snooze=10min, debounce=10min）
14. 本体からプロセス起動、戻り値で**Snooze**選択を反映

    * ✅ テスト: GUI不可環境でフォールバックが動くことなのだ

## フェーズ7：掃除と運用

15. JSONL/ログローテーション、キャッシュ孤児**24h**掃除ジョブ
16. macOS（LaunchAgents）／Windows（Task Scheduler）の**起動テンプレ**整備

    * ✅ テスト: 自動起動後に**最初のレコードが60秒以内**に出ることなのだ

---

# 実装チェックリスト（抜粋）なのだ

* [ ] オフライン時に**例外で止まらず** `ocr_text=""` で継続なのだ
* [ ] キャッシュ容量・枚数上限超えの**古い順ドロップ**が行われるのだ
* [ ] `alerts[]` に `rule_id/level/reason` が必ず入る（空でも配列は存在）なのだ
* [ ] Tkの多重起動を**デバウンス**で抑制できるのだ
* [ ] `ts_utc` のタイムゾーンが**常にZ（UTC）** なのだ

---

このドキュメントを「プロトタイプv0.1の仕様」として凍結して、フェーズ1から順に刻んでいけば**壊れにくく、戻しやすい**進め方になるのだ。実装に入る段で、環境変数名とログパスの決定だけ最初に固定しておくと運用が楽になるのだ。

## 環境変数・設定仕様なのだ

### 環境変数
- `AZURE_OPENAI_ENDPOINT`: Azure OpenAI エンドポイントURL
- `AZURE_OPENAI_KEY`: Azure OpenAI APIキー  
- `DATA_DIR`: データ保存ディレクトリ（デフォルト: `~/.keystats`）

### 設定ファイル
- パス: `~/.keystats/config.ini` または `DATA_DIR/config.ini`
- セクション: `[azure]` `[paths]`
- 優先度: 環境変数 > INIファイル > デフォルト値なのだ

```ini
[azure]
endpoint = https://your-resource.openai.azure.com
key = your-api-key

[paths]  
data_dir = ~/.keystats
```
